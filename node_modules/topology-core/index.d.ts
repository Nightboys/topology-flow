import { Options } from './options';
import { Pen } from './models/pen';
import { Node } from './models/node';
import { Point } from './models/point';
import { Line } from './models/line';
import { TopologyData } from './models/data';
import { Offscreen } from './offscreen';
import { RenderLayer } from './renderLayer';
import { HoverLayer } from './hoverLayer';
import { ActiveLayer } from './activeLayer';
import { AnimateLayer } from './animateLayer';
import { DivLayer } from './divLayer';
import { Rect } from './models/rect';
declare enum MoveInType {
    None = 0,
    Line = 1,
    LineMove = 2,
    LineFrom = 3,
    LineTo = 4,
    LineControlPoint = 5,
    Nodes = 6,
    ResizeCP = 7,
    HoverAnchors = 8,
    Rotate = 9
}
interface ICaches {
    index: number;
    list: TopologyData[];
}
export declare class Topology {
    data: TopologyData;
    clipboard: TopologyData;
    caches: ICaches;
    options: Options;
    parentElem: HTMLElement;
    canvas: RenderLayer;
    offscreen: Offscreen;
    hoverLayer: HoverLayer;
    activeLayer: ActiveLayer;
    animateLayer: AnimateLayer;
    divLayer: DivLayer;
    private subcribe;
    private subcribeImage;
    private imageTimer;
    private subcribeAnimateEnd;
    private subcribeAnimateMoved;
    private subcribeMediaEnd;
    touchedNode: any;
    lastHoverNode: Node;
    lastHoverLine: Line;
    input: HTMLTextAreaElement;
    inputObj: Pen;
    mouseDown: {
        x: number;
        y: number;
    };
    lastTranlated: {
        x: number;
        y: number;
    };
    moveIn: {
        type: MoveInType;
        activeAnchorIndex: number;
        hoverAnchorIndex: number;
        hoverNode: Node;
        hoverLine: Line;
        activeNode: Node;
        lineControlPoint: Point;
    };
    needCache: boolean;
    private tip;
    tipMarkdown: HTMLElement;
    tipElem: HTMLElement;
    private scheduledAnimationFrame;
    private scrolling;
    constructor(parent: string | HTMLElement, options?: Options);
    resize(size?: {
        width: number;
        height: number;
    }): void;
    private ondrop;
    getTouchOffset(touch: Touch): {
        offsetX: number;
        offsetY: number;
    };
    private ontouched;
    addNode(node: Node | any, focus?: boolean): boolean;
    addLine(line: Line, focus?: boolean): boolean;
    addLineByPt(name: string, from: Point, fromArrow: string, to: Point, toArrow: string, strokeStyle?: string, focus?: boolean): Line;
    render(noFocus?: boolean): void;
    open(data?: any): void;
    overflow(): void;
    private setNodeText;
    private onMouseMove;
    private onmousedown;
    private onmouseup;
    private ondblclick;
    private onkeydown;
    private getMoveIn;
    inChildNode(pt: Point, children: Pen[]): any;
    inNode(pt: Point, node: Node, inChild?: boolean): any;
    inLine(point: Point, line: Line): boolean;
    private getLineDock;
    private getPensInRect;
    private getAngle;
    private showInput;
    getRect(pens?: Pen[]): Rect;
    getDockPos(offsetX: number, offsetY: number): {
        x: number;
        y: number;
    };
    cache(): void;
    cacheReplace(pens: Pen[]): void;
    undo(noRedo?: boolean): void;
    redo(): void;
    toImage(type?: string, quality?: any, callback?: any, padding?: {
        left: number;
        top: number;
        right: number;
        bottom: number;
    }, thumbnail?: boolean): string;
    saveAsImage(name?: string, type?: string, quality?: any, padding?: {
        left: number;
        top: number;
        right: number;
        bottom: number;
    }, thumbnail?: boolean): void;
    delete(): void;
    removeNode(node: Node): void;
    removeLine(line: Line): void;
    cut(): void;
    copy(): void;
    paste(): void;
    newId(node: any, idMaps: any): void;
    animate(autoplay?: boolean): void;
    updateProps(cache?: boolean, pens?: Pen[]): void;
    lock(lock: number): void;
    lockPens(pens: Pen[], lock: boolean): void;
    top(pen: Pen): void;
    bottom(pen: Pen): void;
    combine(pens?: Pen[], lockChildren?: boolean): void;
    uncombine(node?: Pen): void;
    private find;
    translate(x: number, y: number, process?: boolean): void;
    scale(scale: number): void;
    scaleTo(scale: number): void;
    round(): void;
    private createMarkdownTip;
    private showTip;
    private hideTip;
    scroll(x: number, y: number): void;
    toComponent(pens?: Pen[]): Node;
    clearBkImg(): void;
    dispatch(event: string, data: any): void;
    destroy(): void;
}
export {};
