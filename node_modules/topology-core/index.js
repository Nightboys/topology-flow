"use strict";
Object.defineProperty(exports, "__esModule", {
  value: true
});
var le5le_store_1 = require("le5le-store");
var options_1 = require("./options");
var pen_1 = require("./models/pen");
var node_1 = require("./models/node");
var point_1 = require("./models/point");
var line_1 = require("./models/line");
var data_1 = require("./models/data");
var status_1 = require("./models/status");
var index_1 = require("./middles/index");
var offscreen_1 = require("./offscreen");
var renderLayer_1 = require("./renderLayer");
var hoverLayer_1 = require("./hoverLayer");
var activeLayer_1 = require("./activeLayer");
var animateLayer_1 = require("./animateLayer");
var divLayer_1 = require("./divLayer");
var rect_1 = require("./models/rect");
var uuid_1 = require("./utils/uuid");
var canvas_1 = require("./utils/canvas");
var rect_2 = require("./utils/rect");
var resizeCursors = ['nw-resize', 'ne-resize', 'se-resize', 'sw-resize'];
var MoveInType;
(function (MoveInType) {
  MoveInType[MoveInType["None"] = 0] = "None";
  MoveInType[MoveInType["Line"] = 1] = "Line";
  MoveInType[MoveInType["LineMove"] = 2] = "LineMove";
  MoveInType[MoveInType["LineFrom"] = 3] = "LineFrom";
  MoveInType[MoveInType["LineTo"] = 4] = "LineTo";
  MoveInType[MoveInType["LineControlPoint"] = 5] = "LineControlPoint";
  MoveInType[MoveInType["Nodes"] = 6] = "Nodes";
  MoveInType[MoveInType["ResizeCP"] = 7] = "ResizeCP";
  MoveInType[MoveInType["HoverAnchors"] = 8] = "HoverAnchors";
  MoveInType[MoveInType["Rotate"] = 9] = "Rotate";
})(MoveInType || (MoveInType = {}));
var dockOffset = 10;
var Topology = /** @class */ (function () {
  function Topology(parent, options) {
    var _this = this;
    this.data = new data_1.TopologyData();
    this.caches = {
      index: 0,
      list: []
    };

    // 自定义箭头
    this.data.fromArrowType = options.fromArrowType || '';
    this.data.toArrowType = options.toArrowType || 'triangleSolid';

    this.input = document.createElement('textarea');
    this.lastTranlated = {
      x: 0,
      y: 0
    };
    this.moveIn = {
      type: MoveInType.None,
      activeAnchorIndex: 0,
      hoverAnchorIndex: 0,
      hoverNode: null,
      hoverLine: null,
      activeNode: null,
      lineControlPoint: null
    };
    this.needCache = false;
    this.tip = '';
    this.scheduledAnimationFrame = false;
    this.scrolling = false;
    this.onMouseMove = function (e) {
      if (_this.scheduledAnimationFrame || _this.data.locked === status_1.Lock.NoEvent) {
        return;
      }
      if (_this.mouseDown && _this.moveIn.type === MoveInType.None) {
        var b = false;
        switch (_this.options.translateKey) {
          case options_1.KeyType.None:
            b = true;
            break;
          case options_1.KeyType.Ctrl:
            if (e.ctrlKey) {
              b = true;
            }
            break;
          case options_1.KeyType.Shift:
            if (e.shiftKey) {
              b = true;
            }
            break;
          case options_1.KeyType.Alt:
            if (e.altKey) {
              b = true;
            }
            break;
          default:
            if (e.ctrlKey || e.altKey) {
              b = true;
            }
        }
        if (b) {
          _this.translate(e.offsetX - _this.mouseDown.x, e.offsetY - _this.mouseDown.y, true);
          return false;
        }
      }
      if (_this.data.locked && _this.mouseDown && _this.moveIn.type !== MoveInType.None) {
        return;
      }
      _this.scheduledAnimationFrame = true;
      var pos = new point_1.Point(e.offsetX, e.offsetY);
      requestAnimationFrame(function () {
        if (!_this.mouseDown) {
          _this.getMoveIn(pos);
          // Render hover anchors.
          if (_this.moveIn.hoverNode !== _this.lastHoverNode) {
            if (_this.lastHoverNode) {
              // Send a move event.
              _this.dispatch('moveOutNode', _this.lastHoverNode);
              _this.hideTip();
              // Clear hover anchors.
              _this.hoverLayer.node = null;

              document.getElementById('tipsPort').style.display = 'none';
            }
            if (_this.moveIn.hoverNode) {
              _this.hoverLayer.node = _this.moveIn.hoverNode;
              // Send a move event.
              _this.dispatch('moveInNode', _this.moveIn.hoverNode);
              _this.showTip(_this.moveIn.hoverNode, pos);
            }
          }
          if (_this.moveIn.hoverLine !== _this.lastHoverLine) {
            if (_this.lastHoverLine) {
              _this.dispatch('moveOutLine', _this.lastHoverLine);
              _this.hideTip();
            }
            if (_this.moveIn.hoverLine) {
              _this.dispatch('moveInLine', _this.moveIn.hoverLine);
              _this.showTip(_this.moveIn.hoverLine, pos);
            }
          }
          if (_this.moveIn.type === MoveInType.LineControlPoint) {
            _this.hoverLayer.hoverLineCP = _this.moveIn.lineControlPoint;
          } else if (_this.hoverLayer.hoverLineCP) {
            _this.hoverLayer.hoverLineCP = null;
          }
          if (_this.moveIn.hoverNode !== _this.lastHoverNode ||
            _this.moveIn.type === MoveInType.HoverAnchors ||
            _this.hoverLayer.lasthoverLineCP !== _this.hoverLayer.hoverLineCP) {
            _this.hoverLayer.lasthoverLineCP = _this.hoverLayer.hoverLineCP;
            _this.render();
          }
          _this.scheduledAnimationFrame = false;
          return;
        }
        // Move out parent element.
        var moveOutX = pos.x + 50 > _this.parentElem.clientWidth + _this.parentElem.scrollLeft;
        var moveOutY = pos.y + 50 > _this.parentElem.clientHeight + _this.parentElem.scrollTop;
        if (moveOutX || moveOutY) {
          _this.dispatch('moveOutParent', pos);
          var resize = false;
          if (pos.x + 50 > _this.divLayer.canvas.clientWidth) {
            _this.canvas.width += 200;
            resize = true;
          }
          if (pos.y + 50 > _this.divLayer.canvas.clientHeight) {
            _this.canvas.height += 200;
            resize = true;
          }
          if (resize) {
            _this.resize({
              width: _this.canvas.width,
              height: _this.canvas.height
            });
          }
          _this.scroll(moveOutX ? 100 : 0, moveOutY ? 100 : 0);
        }
        var moveLeft = pos.x - 100 < _this.parentElem.scrollLeft;
        var moveTop = pos.y - 100 < _this.parentElem.scrollTop;
        if (moveLeft || moveTop) {
          _this.scroll(moveLeft ? -100 : 0, moveTop ? -100 : 0);
        }
        switch (_this.moveIn.type) {
          case MoveInType.None:
            _this.hoverLayer.dragRect = new rect_1.Rect(_this.mouseDown.x, _this.mouseDown.y, pos.x - _this.mouseDown.x, pos.y - _this.mouseDown.y);
            break;
          case MoveInType.Nodes:
            if (_this.activeLayer.locked()) {
              break;
            }
            var x = pos.x - _this.mouseDown.x;
            var y = pos.y - _this.mouseDown.y;
            if (x || y) {
              var offset = _this.getDockPos(x, y);
              _this.activeLayer.move(offset.x ? offset.x : x, offset.y ? offset.y : y);
              _this.needCache = true;
            }
            break;
          case MoveInType.ResizeCP:
            _this.activeLayer.resize(_this.moveIn.activeAnchorIndex, _this.mouseDown, pos);
            _this.dispatch('resizePens', _this.activeLayer.pens);
            _this.needCache = true;
            break;
          case MoveInType.LineTo:
          case MoveInType.HoverAnchors:
            var arrow = _this.data.toArrowType;

            if (_this.moveIn.hoverLine) {
              arrow = _this.moveIn.hoverLine.toArrow;
            }
            if (_this.hoverLayer.line) {
              _this.activeLayer.pens = [_this.hoverLayer.line];
            }
            _this.hoverLayer.lineTo(_this.getLineDock(pos), arrow);
            _this.needCache = true;
            break;
          case MoveInType.LineFrom:
            _this.hoverLayer.lineFrom(_this.getLineDock(pos));
            _this.needCache = true;
            break;
          case MoveInType.LineMove:
            _this.hoverLayer.lineMove(pos, _this.mouseDown);
            _this.needCache = true;
            break;
          case MoveInType.LineControlPoint:
            _this.moveIn.hoverLine.controlPoints[_this.moveIn.lineControlPoint.id].x = pos.x;
            _this.moveIn.hoverLine.controlPoints[_this.moveIn.lineControlPoint.id].y = pos.y;
            _this.moveIn.hoverLine.textRect = null;
            if (index_1.drawLineFns[_this.moveIn.hoverLine.name] && index_1.drawLineFns[_this.moveIn.hoverLine.name].dockControlPointFn) {
              index_1.drawLineFns[_this.moveIn.hoverLine.name].dockControlPointFn(_this.moveIn.hoverLine.controlPoints[_this.moveIn.lineControlPoint.id], _this.moveIn.hoverLine);
            }
            _this.needCache = true;
            le5le_store_1.Store.set('LT:updateLines', [_this.moveIn.hoverLine]);
            break;
          case MoveInType.Rotate:
            if (_this.activeLayer.pens.length) {
              _this.activeLayer.offsetRotate(_this.getAngle(pos));
              _this.activeLayer.updateLines();
            }
            _this.needCache = true;
            break;
        }
        _this.render();
        _this.scheduledAnimationFrame = false;
      });
    };
    this.onmousedown = function (e) {
      _this.mouseDown = {
        x: e.offsetX,
        y: e.offsetY
      };
      if (e.altKey) {
        _this.divLayer.canvas.style.cursor = 'move';
      }
      if (_this.inputObj) {
        _this.setNodeText();
      }
      switch (_this.moveIn.type) {
        // Click the space.
        case MoveInType.None:
          _this.activeLayer.clear();
          _this.hoverLayer.clear();
          _this.dispatch('space', _this.mouseDown);
          break;
          // Click a line.
        case MoveInType.Line:
        case MoveInType.LineControlPoint:
          if (e.ctrlKey) {
            _this.activeLayer.add(_this.moveIn.hoverLine);
            _this.dispatch('multi', _this.activeLayer.pens);
          } else {
            _this.activeLayer.pens = [_this.moveIn.hoverLine];
            _this.dispatch('line', _this.moveIn.hoverLine);
          }
          if (_this.data.locked) {
            _this.moveIn.hoverLine.click();
          }
          break;
        case MoveInType.LineMove:
          _this.hoverLayer.initLine = new line_1.Line(_this.moveIn.hoverLine);
          // tslint:disable-next-line:no-switch-case-fall-through
        case MoveInType.LineFrom:
        case MoveInType.LineTo:
          _this.activeLayer.pens = [_this.moveIn.hoverLine];
          _this.dispatch('line', _this.moveIn.hoverLine);
          _this.hoverLayer.line = _this.moveIn.hoverLine;
          break;
        case MoveInType.HoverAnchors:
          // console.log('_this.moveIn.hoverNode==', _this.moveIn.hoverNode.rotatedAnchors)
          _this.hoverLayer.line = _this.addLineByPt(_this.data.lineName, new point_1.Point(_this.moveIn.hoverNode.rotatedAnchors[_this.moveIn.hoverAnchorIndex].x, _this.moveIn.hoverNode.rotatedAnchors[_this.moveIn.hoverAnchorIndex].y, _this.moveIn.hoverNode.rotatedAnchors[_this.moveIn.hoverAnchorIndex].direction, _this.moveIn.hoverNode.rotatedAnchors[_this.moveIn.hoverAnchorIndex].anchorIndex, _this.moveIn.hoverNode.id), _this.data.fromArrowType, new point_1.Point(_this.moveIn.hoverNode.rotatedAnchors[_this.moveIn.hoverAnchorIndex].x, _this.moveIn.hoverNode.rotatedAnchors[_this.moveIn.hoverAnchorIndex].y), _this.data.toArrowType, _this.data.strokeStyle, false, _this.moveIn.hoverNode);
          // tslint:disable-next-line:no-switch-case-fall-through
        case MoveInType.Nodes:
          if (!_this.moveIn.activeNode) {
            break;
          }
          if (e.ctrlKey) {
            if (_this.activeLayer.hasInAll(_this.moveIn.hoverNode)) {
              _this.activeLayer.setPens([_this.moveIn.hoverNode]);
              _this.dispatch('node', _this.moveIn.hoverNode);
            } else if (!_this.activeLayer.has(_this.moveIn.activeNode)) {
              _this.activeLayer.add(_this.moveIn.activeNode);
              if (_this.activeLayer.pens.length > 1) {
                _this.dispatch('multi', _this.activeLayer.pens);
              } else {
                _this.dispatch('node', _this.moveIn.activeNode);
              }
            }
          } else if (e.shiftKey) {
            _this.activeLayer.setPens([_this.moveIn.hoverNode]);
            _this.dispatch('node', _this.moveIn.hoverNode);
          } else {
            _this.activeLayer.setPens([_this.moveIn.activeNode]);
            _this.dispatch('node', _this.moveIn.activeNode);
          }
          if (_this.data.locked) {
            _this.moveIn.activeNode.click();
          }
          break;
      }
      // Save node rects to move.
      if (_this.activeLayer.pens.length) {
        _this.activeLayer.saveNodeRects();
      }
      _this.render();
    };
    this.onmouseup = function (e) {
      _this.mouseDown = null;
      _this.lastTranlated.x = 0;
      _this.lastTranlated.y = 0;
      _this.hoverLayer.dockAnchor = null;
      _this.hoverLayer.dockLineX = 0;
      _this.hoverLayer.dockLineY = 0;
      _this.divLayer.canvas.style.cursor = 'default';
      if (_this.hoverLayer.dragRect) {
        _this.getPensInRect(_this.hoverLayer.dragRect);
        if (_this.activeLayer.pens && _this.activeLayer.pens.length) {
          _this.dispatch('multi', _this.activeLayer.pens);
        }
      } else {
        switch (_this.moveIn.type) {
          // Add the line.
          case MoveInType.HoverAnchors:
            // New active.
            if (_this.hoverLayer.line) {
              if (_this.hoverLayer.line.to.id || !_this.options.disableEmptyLine) {
                _this.activeLayer.pens = [_this.hoverLayer.line];
                _this.dispatch('addLine', _this.hoverLayer.line);
              } else {
                _this.data.pens.pop();
              }
            }
            _this.offscreen.render();
            _this.hoverLayer.line = null;
            break;
          case MoveInType.Rotate:
            _this.activeLayer.updateRotate();
            break;
          case MoveInType.LineControlPoint:
            le5le_store_1.Store.set('pts-' + _this.moveIn.hoverLine.id, null);
            break;
        }
      }
      _this.hoverLayer.dragRect = null;
      _this.render();
      if (_this.needCache) {
        _this.cache();
      }
      _this.needCache = false;
    };
    this.ondblclick = function (e) {
      if (_this.moveIn.hoverNode) {
        _this.dispatch('dblclick', {
          node: _this.moveIn.hoverNode
        });
        if (_this.moveIn.hoverNode.getTextRect().hit(new point_1.Point(e.offsetX, e.offsetY))) {
          _this.showInput(_this.moveIn.hoverNode);
        }
        if (_this.data.locked) {
          _this.moveIn.hoverNode.dblclick();
        }
      } else if (_this.moveIn.hoverLine) {
        _this.dispatch('dblclick', {
          line: _this.moveIn.hoverLine
        });
        if (!_this.moveIn.hoverLine.text || _this.moveIn.hoverLine.getTextRect().hit(new point_1.Point(e.offsetX, e.offsetY))) {
          _this.showInput(_this.moveIn.hoverLine);
        }
        if (_this.data.locked) {
          _this.moveIn.hoverNode.dblclick();
        }
      }
    };
    this.onkeydown = function (key) {
      if (_this.data.locked) {
        return;
      }
      var done = false;
      var moveX = 0;
      var moveY = 0;
      switch (key.keyCode) {
        // Delete
        case 8:
        case 46:
          if (key.target.tagName !== 'INPUT' && key.target.tagName !== 'TEXTAREA' &&
            (_this.activeLayer.pens.length)) {
            _this.delete();
          }
          break;
          // Left
        case 37:
          moveX = -5;
          if (key.ctrlKey) {
            moveX = -1;
          }
          done = true;
          break;
          // Top
        case 38:
          moveY = -5;
          if (key.ctrlKey) {
            moveY = -1;
          }
          done = true;
          break;
          // Right
        case 39:
          moveX = 5;
          if (key.ctrlKey) {
            moveX = 1;
          }
          done = true;
          break;
          // Down
        case 40:
          moveY = 5;
          if (key.ctrlKey) {
            moveY = 1;
          }
          done = true;
          break;
        case 88:
          if (key.ctrlKey && key.target.tagName !== 'INPUT' && key.target.tagName !== 'TEXTAREA') {
            _this.cut();
          }
          break;
        case 67:
          if (key.ctrlKey && key.target.tagName !== 'INPUT' && key.target.tagName !== 'TEXTAREA') {
            _this.copy();
          }
          break;
        case 86:
          if (key.ctrlKey && key.target.tagName !== 'INPUT' && key.target.tagName !== 'TEXTAREA') {
            _this.paste();
          }
          break;
        case 89: // Y
          if (key.ctrlKey) {
            _this.redo();
          }
          break;
        case 90: // Z
          if (key.shiftKey) {
            _this.redo();
          } else {
            _this.undo();
          }
          break;
      }
      if (!done) {
        return;
      }
      if (moveX || moveY) {
        _this.activeLayer.saveNodeRects();
        _this.activeLayer.move(moveX, moveY);
        _this.overflow();
        _this.animateLayer.animate();
      }
      _this.render();
      _this.cache();
    };
    le5le_store_1.Store.set('topology-data', this.data);
    if (!options) {
      options = {};
    }
    var font = Object.assign({}, options_1.DefalutOptions.font, options.font);
    options.font = font;
    this.options = Object.assign({}, options_1.DefalutOptions, options);
    if (typeof parent === 'string') {
      this.parentElem = document.getElementById(parent);
    } else {
      this.parentElem = parent;
    }
    this.parentElem.style.position = 'relative';
    this.activeLayer = new activeLayer_1.ActiveLayer(this.options);
    this.hoverLayer = new hoverLayer_1.HoverLayer(this.options);
    this.animateLayer = new animateLayer_1.AnimateLayer(this.options);
    this.offscreen = new offscreen_1.Offscreen(this.parentElem, this.options);
    this.canvas = new renderLayer_1.RenderLayer(this.parentElem, this.options);
    this.divLayer = new divLayer_1.DivLayer(this.parentElem, this.options);
    this.resize();
    this.divLayer.canvas.ondragover = function (event) {
      return event.preventDefault();
    };
    this.divLayer.canvas.ondrop = function (event) {
      _this.ondrop(event);
    };
    this.subcribe = le5le_store_1.Store.subscribe('LT:render', function () {
      _this.render();
    });
    this.subcribeImage = le5le_store_1.Store.subscribe('LT:imageLoaded', function () {
      if (_this.imageTimer) {
        clearTimeout(_this.imageTimer);
      }
      _this.imageTimer = setTimeout(function () {
        _this.render();
      }, 100);
    });
    this.subcribeAnimateMoved = le5le_store_1.Store.subscribe('LT:rectChanged', function (e) {
      _this.activeLayer.updateLines(_this.data.pens);
    });
    this.subcribeMediaEnd = le5le_store_1.Store.subscribe('mediaEnd', function (node) {
      if (node.nextPlay) {
        _this.animateLayer.pens.push.apply(_this.animateLayer.pens, _this.animateLayer.readyPlay(node.nextPlay));
        _this.animateLayer.animate();
      }
      _this.dispatch('mediaEnd', node);
    });
    this.subcribeAnimateEnd = le5le_store_1.Store.subscribe('animateEnd', function (e) {
      if (!e) {
        return;
      }
      switch (e.type) {
        case 'node':
          _this.offscreen.render();
          break;
      }
      _this.divLayer.playNext(e.data.nextAnimate);
      _this.dispatch('animateEnd', e);
    });
    this.divLayer.canvas.onmousemove = this.onMouseMove;
    this.divLayer.canvas.onmousedown = this.onmousedown;
    this.divLayer.canvas.onmouseup = this.onmouseup;
    this.divLayer.canvas.ondblclick = this.ondblclick;
    this.divLayer.canvas.tabIndex = 0;
    this.divLayer.canvas.onblur = function () {
      _this.mouseDown = null;
    };
    this.divLayer.canvas.onwheel = function (event) {
      if (_this.options.disableScale) {
        return;
      }
      switch (_this.options.scaleKey) {
        case options_1.KeyType.None:
          break;
        case options_1.KeyType.Ctrl:
          if (!event.ctrlKey) {
            return;
          }
          break;
        case options_1.KeyType.Shift:
          if (!event.shiftKey) {
            return;
          }
          break;
        case options_1.KeyType.Alt:
          if (!event.altKey) {
            return;
          }
          break;
        default:
          if (!event.ctrlKey && !event.altKey) {
            return;
          }
      }
      event.preventDefault();
      if (event.deltaY < 0) {
        _this.scale(1.1);
      } else {
        _this.scale(0.9);
      }
      _this.divLayer.canvas.focus();
      return false;
    };
    this.divLayer.canvas.ontouchend = function (event) {
      _this.ontouched(event);
    };
    switch (this.options.keydown) {
      case options_1.KeydownType.Document:
        document.onkeydown = this.onkeydown;
        break;
      case options_1.KeydownType.Canvas:
        this.divLayer.canvas.onkeydown = this.onkeydown;
        break;
    }
    this.input.style.position = 'absolute';
    this.input.style.zIndex = '-1';
    this.input.style.left = '-1000px';
    this.input.style.width = '0';
    this.input.style.height = '0';
    this.input.style.outline = 'none';
    this.input.style.border = '1px solid #cdcdcd';
    this.input.style.resize = 'none';
    this.parentElem.appendChild(this.input);
    this.createMarkdownTip();
    this.cache();
    var timer;
    window.onresize = function () {
      if (timer) {
        clearTimeout(timer);
      }
      timer = setTimeout(function () {
        _this.resize();
        _this.overflow();
      }, 100);
    };
  }
  Topology.prototype.resize = function (size) {
    this.canvas.resize(size);
    this.offscreen.resize(size);
    this.divLayer.resize(size);
    this.render();
    this.dispatch('resize', size);
  };
  Topology.prototype.ondrop = function (event) {
    event.preventDefault();
    try {
      var json = JSON.parse(event.dataTransfer.getData('Text'));
      json.rect.x = (event.offsetX - json.rect.width / 2) << 0;
      json.rect.y = (event.offsetY - json.rect.height / 2) << 0;
      if (json.name === 'lineAlone') {
        this.addLineByPt(this.data.lineName, new point_1.Point(json.rect.x, json.rect.y), this.data.fromArrowType, new point_1.Point(json.rect.x + json.rect.width, json.rect.y + json.rect.height), this.data.toArrowType, this.options.color, true);
      } else {
        var node = new node_1.Node(json);
        this.addNode(node, true);
        if (node.name === 'div') {
          this.dispatch('LT:addDiv', node);
        }
      }
      this.divLayer.canvas.focus();
    } catch (e) {}
  };
  Topology.prototype.getTouchOffset = function (touch) {
    var currentTarget = this.parentElem;
    var x = 0;
    var y = 0;
    while (currentTarget) {
      x += currentTarget.offsetLeft;
      y += currentTarget.offsetTop;
      currentTarget = currentTarget.offsetParent;
    }
    return {
      offsetX: touch.pageX - x,
      offsetY: touch.pageY - y
    };
  };
  Topology.prototype.ontouched = function (event) {
    if (!this.touchedNode) {
      return;
    }
    var pos = this.getTouchOffset(event.changedTouches[0]);
    this.touchedNode.rect.x = pos.offsetX - this.touchedNode.rect.width / 2;
    this.touchedNode.rect.y = pos.offsetY - this.touchedNode.rect.height / 2;
    this.addNode(new node_1.Node(this.touchedNode), true);
    this.touchedNode = undefined;
  };
  Topology.prototype.addNode = function (node, focus) {
    if (focus === void 0) {
      focus = false;
    }
    if (this.data.locked || !index_1.drawNodeFns[node.name]) {
      return false;
    }
    // if it's not a Node
    if (!node.init) {
      node = new node_1.Node(node);
    }
    if (!node.strokeStyle && this.options.color) {
      node.strokeStyle = this.options.color;
    }
    for (var key in node.font) {
      if (!node.font[key]) {
        node.font[key] = this.options.font[key];
      }
    }
    if (this.data.scale !== 1) {
      node.scale(this.data.scale);
    }
    this.data.pens.push(node);
    // New active.
    if (focus) {
      this.activeLayer.setPens([node]);
    }
    this.render();
    this.cache();
    this.dispatch('addNode', node);
    return true;
  };
  Topology.prototype.addLine = function (line, focus) {
    if (focus === void 0) {
      focus = false;
    }
    if (this.data.locked) {
      return false;
    }
    // New active.
    if (focus) {
      this.activeLayer.setPens([line]);
    }
    this.data.pens.push(line);
    this.render();
    this.cache();
    this.dispatch('addLine', line);
  };
  Topology.prototype.addLineByPt = function (name, from, fromArrow, to, toArrow, strokeStyle, focus, node) {
    if (strokeStyle === void 0) {
      strokeStyle = this.options.color;
    }
    if (focus === void 0) {
      focus = false;
    }

    // console.log('from====', from)
    // console.log('to====', to)
    // console.log('node====', node)

    var line = new line_1.Line({
      name: name,
      from: from,
      fromArrow: fromArrow,
      to: to,
      toArrow: toArrow,
      strokeStyle: strokeStyle
    });

    if (from.id == node.id) {
      // line.from.props = node.anchors[from.anchorIndex].props;
      node.anchors.forEach((v, i) => {
        if (v.anchorIndex == from.anchorIndex) {
          line.from.props = v.props;
        }
      })
    }

    line.calcControlPoints(true);
    this.addLine(line, focus);
    return line;
  };
  // Render or redraw
  Topology.prototype.render = function (noFocus) {
    if (noFocus === void 0) {
      noFocus = false;
    }
    if (noFocus) {
      this.activeLayer.pens = [];
      this.hoverLayer.node = null;
      this.hoverLayer.line = null;
    }
    this.offscreen.render();
    this.canvas.render();
  };
  // open - redraw by the data
  Topology.prototype.open = function (data) {
    if (!data) {
      data = {
        pens: []
      };
    }
    this.divLayer.clear();
    // tslint:disable-next-line:forin
    for (var key in node_1.images) {
      delete node_1.images[key];
    }
    this.animateLayer.stop();
    this.lock(data.locked || status_1.Lock.None);
    if (data.lineName) {
      this.data.lineName = data.lineName;
    }
    this.data.scale = data.scale || 1;
    le5le_store_1.Store.set('LT:scale', this.data.scale);
    this.dispatch('scale', this.data.scale);
    this.data.bkColor = data.bkColor;
    this.data.bkImage = data.bkImage;
    this.data.pens = [];
    // for old data.
    if (data.nodes) {
      for (var _i = 0, _a = data.nodes; _i < _a.length; _i++) {
        var item = _a[_i];
        this.data.pens.push(new node_1.Node(item));
      }
      for (var _b = 0, _c = data.lines; _b < _c.length; _b++) {
        var item = _c[_b];
        this.data.pens.push(new line_1.Line(item));
      }
    }
    // end.
    if (data.pens) {
      for (var _d = 0, _e = data.pens; _d < _e.length; _d++) {
        var item = _e[_d];
        if (!item.from) {
          this.data.pens.push(new node_1.Node(item));
        } else {
          this.data.pens.push(new line_1.Line(item));
        }
      }
    }
    this.data.grid = data.grid;
    if (typeof data.data === 'object') {
      this.data.data = JSON.parse(JSON.stringify(data.data));
    } else {
      this.data.data = data.data || '';
    }
    this.caches.list = [];
    this.cache();
    this.overflow();
    this.render(true);
    this.animate();
  };
  Topology.prototype.overflow = function () {
    var rect = this.getRect();
    var _a = this.canvas,
      width = _a.width,
      height = _a.height;
    var ex = rect.ex,
      ey = rect.ey;
    if (ex > width) {
      width = ex + 200;
    }
    if (ey > height) {
      height = ey + 200;
    }
    this.resize({
      width: width,
      height: height
    });
  };
  Topology.prototype.setNodeText = function () {
    this.inputObj.text = this.input.value;
    this.input.style.zIndex = '-1';
    this.input.style.left = '-1000px';
    this.input.style.width = '0';
    this.cache();
    this.offscreen.render();
    this.dispatch('setText', this.inputObj);
    this.inputObj = null;
  };
  Topology.prototype.getMoveIn = function (pt) {
    this.lastHoverNode = this.moveIn.hoverNode;
    this.lastHoverLine = this.moveIn.hoverLine;
    this.moveIn.type = MoveInType.None;
    this.moveIn.hoverNode = null;
    this.moveIn.lineControlPoint = null;
    this.moveIn.hoverLine = null;
    this.hoverLayer.hoverAnchorIndex = -1;
    if (!this.data.locked &&
      !(this.activeLayer.pens.length === 1 && this.activeLayer.pens[0].type) &&
      !this.activeLayer.locked() &&
      this.activeLayer.rotateCPs[0] &&
      this.activeLayer.rotateCPs[0].hit(pt, 15)) {
      this.moveIn.type = MoveInType.Rotate;
      this.divLayer.canvas.style.cursor = "url(\"" + this.options.rotateCursor + "\"), auto";
      return;
    }
    if (this.activeLayer.pens.length && canvas_1.pointInRect(pt, this.activeLayer.sizeCPs)) {
      this.moveIn.type = MoveInType.Nodes;
    }
    if (!this.data.locked && !this.activeLayer.locked() && !this.options.hideSizeCP) {
      if (this.activeLayer.pens.length > 1 || (!this.activeLayer.pens[0].type && !this.activeLayer.pens[0].hideSizeCP)) {
        for (var i = 0; i < this.activeLayer.sizeCPs.length; ++i) {
          if (this.activeLayer.sizeCPs[i].hit(pt, 10)) {
            this.moveIn.type = MoveInType.ResizeCP;
            this.moveIn.activeAnchorIndex = i;
            this.divLayer.canvas.style.cursor = resizeCursors[i];
            return;
          }
        }
      }
    }
    // In active line.
    for (var _i = 0, _a = this.activeLayer.pens; _i < _a.length; _i++) {
      var item = _a[_i];
      if (!(item instanceof line_1.Line)) {
        continue;
      }
      for (var i = 0; i < item.controlPoints.length; ++i) {
        if (!item.locked && item.controlPoints[i].hit(pt, 10)) {
          item.controlPoints[i].id = i;
          this.moveIn.type = MoveInType.LineControlPoint;
          this.moveIn.lineControlPoint = item.controlPoints[i];
          this.moveIn.hoverLine = item;
          this.divLayer.canvas.style.cursor = 'pointer';
          return;
        }
      }
      if (this.inLine(pt, item)) {
        return;
      }
    }
    this.divLayer.canvas.style.cursor = 'default';

    // console.log('data=====', this.data)

    for (var _b = 0, _c = this.data.pens; _b < _c.length; _b++) {
      var item = _c[_b];
      if (item instanceof node_1.Node) {
        this.inNode(pt, item);
      }
    }
    if (this.moveIn.type === MoveInType.HoverAnchors) {
      return;
    }
    for (var _d = 0, _e = this.data.pens; _d < _e.length; _d++) {
      var item = _e[_d];
      if (item instanceof line_1.Line) {
        this.inLine(pt, item);
      }
    }
  };
  Topology.prototype.inChildNode = function (pt, children) {
    if (!children) {
      return null;
    }
    for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
      var item = children_1[_i];
      if (item.type === pen_1.PenType.Line) {
        continue;
      }
      var node = this.inChildNode(pt, item.children);
      if (node) {
        return node;
      }
      node = this.inNode(pt, item, true);
      if (node) {
        return node;
      }
    }
    return null;
  };
  Topology.prototype.inNode = function (pt, node, inChild) {
    if (inChild === void 0) {
      inChild = false;
    }
    if (this.data.locked === status_1.Lock.NoEvent) {
      return null;
    }
    var child = this.inChildNode(pt, node.children);
    if (child) {
      return child;
    }
    if (node.hit(pt)) {
      this.moveIn.hoverNode = node;
      this.moveIn.type = MoveInType.Nodes;
      this.divLayer.canvas.style.cursor = 'move';
      // Too small
      if (!(this.options.hideAnchor || node.hideAnchor || node.rect.width < 20 || node.rect.height < 20)) {
        for (var j = 0; j < node.rotatedAnchors.length; ++j) {
          if (node.rotatedAnchors[j].hit(pt, 5)) {
            if (!this.mouseDown && node.rotatedAnchors[j].mode === status_1.AnchorMode.In) {
              continue;
            }
            this.moveIn.type = MoveInType.HoverAnchors;
            this.moveIn.hoverAnchorIndex = j;
            this.hoverLayer.hoverAnchorIndex = j;
            this.divLayer.canvas.style.cursor = 'crosshair';
            break;
          }
        }
      }
      if (!inChild) {
        this.moveIn.activeNode = this.moveIn.hoverNode;
      }
      return node;
    }
    if (this.options.hideAnchor || node.hideAnchor || this.data.locked || node.locked) {
      return null;
    }
    if (node.hit(pt, 5)) {

      for (var j = 0; j < node.rotatedAnchors.length; ++j) {
        if (node.rotatedAnchors[j].hit(pt, 5)) {
          // 用户自定义端口提示文字
          var tipsPort = document.getElementById('tipsPort');
          tipsPort.style.position = 'absolute';
          tipsPort.style.left = node.anchors[j].x + 10 + 'px';
          tipsPort.style.top = node.anchors[j].y - 10 + 'px';
          tipsPort.style.zIndex = 9999;
          tipsPort.style.background = 'green';
          tipsPort.style.padding = '2px 5px';
          tipsPort.style.fontSize = '12px';
          tipsPort.style.color = '#fff';
          tipsPort.style.borderRadius = '2px';
          tipsPort.style.cursor = 'default';
          tipsPort.innerHTML = node.anchors[j].props.title;
          tipsPort.style.display = 'block';

          if (!this.mouseDown && node.rotatedAnchors[j].mode === status_1.AnchorMode.In) {
            continue;
          }
          this.moveIn.hoverNode = node;
          this.moveIn.type = MoveInType.HoverAnchors;
          this.moveIn.hoverAnchorIndex = j;
          this.hoverLayer.hoverAnchorIndex = j;
          this.divLayer.canvas.style.cursor = 'crosshair';

          if (!inChild) {
            this.moveIn.activeNode = node;
          }
          return node;
        }
      }
    }
    return null;
  };
  Topology.prototype.inLine = function (point, line) {
    if (line.from.hit(point, 10)) {
      this.moveIn.type = MoveInType.LineFrom;
      this.moveIn.hoverLine = line;
      if (this.data.locked || line.locked) {
        this.divLayer.canvas.style.cursor = 'pointer';
      } else {
        this.divLayer.canvas.style.cursor = 'move';
      }
      return true;
    }
    if (line.to.hit(point, 10)) {
      this.moveIn.type = MoveInType.LineTo;
      this.moveIn.hoverLine = line;
      if (this.data.locked || line.locked) {
        this.divLayer.canvas.style.cursor = 'pointer';
      } else {
        this.divLayer.canvas.style.cursor = 'move';
      }
      return true;
    }
    if (line.pointIn(point)) {
      this.moveIn.type = MoveInType.LineMove;
      this.moveIn.hoverLine = line;
      this.divLayer.canvas.style.cursor = 'pointer';
      if (line.from.id || line.to.id) {
        this.moveIn.type = MoveInType.Line;
      }
      return true;
    }
    return false;
  };
  Topology.prototype.getLineDock = function (point) {
    this.hoverLayer.dockAnchor = null;
    for (var _i = 0, _a = this.data.pens; _i < _a.length; _i++) {
      var item = _a[_i];
      if (item instanceof node_1.Node) {
        if (item.rect.hit(point, 10)) {
          this.hoverLayer.node = item;
        }
        for (var i = 0; i < item.rotatedAnchors.length; ++i) {
          if (item.rotatedAnchors[i].mode && item.rotatedAnchors[i].mode !== status_1.AnchorMode.In) {
            continue;
          }
          if (item.rotatedAnchors[i].hit(point, 10)) {
            point.id = item.id;
            point.anchorIndex = i;
            point.direction = item.rotatedAnchors[point.anchorIndex].direction;
            point.x = item.rotatedAnchors[point.anchorIndex].x;
            point.y = item.rotatedAnchors[point.anchorIndex].y;
            this.hoverLayer.dockAnchor = item.rotatedAnchors[i];
            break;
          }
        }
      } else if (item instanceof line_1.Line) {
        if (item.id === this.hoverLayer.line.id) {
          continue;
        }
        if (item.from.hit(point, 10)) {
          point.x = item.from.x;
          point.y = item.from.y;
          this.hoverLayer.dockAnchor = item.from;
          break;
        }
        if (item.to.hit(point, 10)) {
          point.x = item.to.x;
          point.y = item.to.y;
          this.hoverLayer.dockAnchor = item.to;
          break;
        }
        if (item.controlPoints) {
          for (var _b = 0, _c = item.controlPoints; _b < _c.length; _b++) {
            var cp = _c[_b];
            if (cp.hit(point, 10)) {
              point.x = cp.x;
              point.y = cp.y;
              this.hoverLayer.dockAnchor = cp;
              break;
            }
          }
        }
      }
      if (this.hoverLayer.dockAnchor) {
        break;
      }
    }

    // console.log('point====', point)
    // point.data = this.hoverLayer.node.anchors;

    if (point.id) {
      point.props = this.hoverLayer.node.anchors[point.anchorIndex].props;
      // point.anchorIndex = this.hoverLayer.node.anchors[point.anchorIndex].anchorIndex;
    }
    return point;
  };
  Topology.prototype.getPensInRect = function (rect) {
    if (rect.width < 0) {
      rect.width = -rect.width;
      rect.x = rect.ex;
      rect.ex = rect.x + rect.width;
    }
    if (rect.height < 0) {
      rect.height = -rect.height;
      rect.y = rect.ey;
      rect.ey = rect.y + rect.height;
    }
    this.activeLayer.pens = [];
    for (var _i = 0, _a = this.data.pens; _i < _a.length; _i++) {
      var item = _a[_i];
      if (item instanceof node_1.Node) {
        if (rect.hitByRect(item.rect)) {
          this.activeLayer.add(item);
        }
      }
      if (item instanceof line_1.Line) {
        if (rect.hit(item.from) && rect.hit(item.to)) {
          this.activeLayer.add(item);
        }
      }
    }
  };
  Topology.prototype.getAngle = function (pt) {
    if (pt.x === this.activeLayer.rect.center.x) {
      return pt.y <= this.activeLayer.rect.center.y ? 0 : 180;
    }
    if (pt.y === this.activeLayer.rect.center.y) {
      return pt.x < this.activeLayer.rect.center.x ? 270 : 90;
    }
    var x = pt.x - this.activeLayer.rect.center.x;
    var y = pt.y - this.activeLayer.rect.center.y;
    var angle = (Math.atan(Math.abs(x / y)) / (2 * Math.PI)) * 360;
    if (x > 0 && y > 0) {
      angle = 180 - angle;
    } else if (x < 0 && y > 0) {
      angle += 180;
    } else if (x < 0 && y < 0) {
      angle = 360 - angle;
    }
    if (this.activeLayer.pens.length === 1) {
      return angle - this.activeLayer.pens[0].rotate;
    }
    return angle;
  };
  Topology.prototype.showInput = function (item) {
    if (this.data.locked || item.locked || item.hideInput || this.options.hideInput) {
      return;
    }
    this.inputObj = item;
    var textRect = item.getTextRect();
    this.input.value = item.text || '';
    this.input.style.left = textRect.x + 'px';
    this.input.style.top = textRect.y + 'px';
    this.input.style.width = textRect.width + 'px';
    this.input.style.height = textRect.height + 'px';
    this.input.style.zIndex = '1000';
    this.input.focus();
  };
  Topology.prototype.getRect = function (pens) {
    if (!pens) {
      pens = this.data.pens;
    }
    return rect_2.getRect(pens);
  };
  // Get a dock rect for moving nodes.
  Topology.prototype.getDockPos = function (offsetX, offsetY) {
    this.hoverLayer.dockLineX = 0;
    this.hoverLayer.dockLineY = 0;
    var offset = {
      x: 0,
      y: 0
    };
    var x = 0;
    var y = 0;
    var disX = dockOffset;
    var disY = dockOffset;
    for (var _i = 0, _a = this.activeLayer.dockWatchers; _i < _a.length; _i++) {
      var activePt = _a[_i];
      for (var _b = 0, _c = this.data.pens; _b < _c.length; _b++) {
        var item = _c[_b];
        if (!(item instanceof node_1.Node) || this.activeLayer.has(item) || item.name === 'text') {
          continue;
        }
        if (!item.dockWatchers) {
          item.getDockWatchers();
        }
        for (var _d = 0, _e = item.dockWatchers; _d < _e.length; _d++) {
          var p = _e[_d];
          x = Math.abs(p.x - activePt.x - offsetX);
          if (x < disX) {
            disX = -99999;
            offset.x = p.x - activePt.x;
            this.hoverLayer.dockLineX = p.x | 0;
          }
          y = Math.abs(p.y - activePt.y - offsetY);
          if (y < disY) {
            disY = -99999;
            offset.y = p.y - activePt.y;
            this.hoverLayer.dockLineY = p.y | 0;
          }
        }
      }
    }
    return offset;
  };
  Topology.prototype.cache = function () {
    if (this.caches.index < this.caches.list.length - 1) {
      this.caches.list.splice(this.caches.index + 1, this.caches.list.length - this.caches.index - 1);
    }
    var data = new data_1.TopologyData(this.data);
    this.caches.list.push(data);
    if (this.caches.list.length > this.options.cacheLen) {
      this.caches.list.shift();
    }
    this.caches.index = this.caches.list.length - 1;
  };
  Topology.prototype.cacheReplace = function (pens) {
    if (pens && pens.length) {
      var needPenMap = {};
      for (var i = 0, len = pens.length; i < len; i++) {
        var pen = pens[i];
        var id = pen.id;
        if (pen instanceof node_1.Node) {
          needPenMap[id] = new node_1.Node(pen);
        } else if (pen instanceof line_1.Line) {
          needPenMap[id] = new line_1.Line(pen);
        }
      }
      var cacheListData = this.caches.list[0];
      if (!cacheListData) {
        return;
      }
      for (var i = 0, len = cacheListData.pens.length; i < len; i++) {
        var id = cacheListData.pens[i].id;
        if (needPenMap[id]) {
          cacheListData.pens[i] = needPenMap[id];
        }
      }
    }
  };
  Topology.prototype.undo = function (noRedo) {
    if (noRedo === void 0) {
      noRedo = false;
    }
    if (this.data.locked || this.caches.index < 1) {
      return;
    }
    this.divLayer.clear();
    var data = new data_1.TopologyData(this.caches.list[--this.caches.index]);
    this.data.pens.splice(0, this.data.pens.length);
    this.data.pens.push.apply(this.data.pens, data.pens);
    this.render(true);
    this.divLayer.render();
    if (noRedo) {
      this.caches.list.splice(this.caches.index + 1, this.caches.list.length - this.caches.index - 1);
    }
    this.dispatch('undo', this.data);
  };
  Topology.prototype.redo = function () {
    if (this.data.locked || this.caches.index > this.caches.list.length - 2) {
      return;
    }
    this.divLayer.clear();
    var data = new data_1.TopologyData(this.caches.list[++this.caches.index]);
    this.data.pens.splice(0, this.data.pens.length);
    this.data.pens.push.apply(this.data.pens, data.pens);
    this.render(true);
    this.divLayer.render();
    this.dispatch('redo', this.data);
  };
  Topology.prototype.toImage = function (type, quality, callback, padding, thumbnail) {
    if (thumbnail === void 0) {
      thumbnail = true;
    }
    var rect = new rect_1.Rect(0, 0, this.canvas.width, this.canvas.height);
    if (thumbnail) {
      rect = this.getRect();
    }
    if (!padding) {
      padding = {
        left: 10,
        top: 10,
        right: 10,
        bottom: 10
      };
    }
    rect.x -= padding.left;
    rect.y -= padding.top;
    rect.width += padding.left + padding.right;
    rect.height += padding.top + padding.bottom;
    rect.round();
    var srcRect = rect.clone();
    srcRect.scale(this.offscreen.getDpiRatio(), new point_1.Point(0, 0));
    srcRect.round();
    var canvas = document.createElement('canvas');
    canvas.width = srcRect.width;
    canvas.height = srcRect.height;
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';
    var ctx = canvas.getContext('2d');
    if (type && type !== 'image/png') {
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    ctx.drawImage(this.canvas.canvas, srcRect.x, srcRect.y, srcRect.width, srcRect.height, 0, 0, srcRect.width, srcRect.height);
    if (callback) {
      canvas.toBlob(callback);
      return '';
    }
    return canvas.toDataURL(type, quality);
  };
  Topology.prototype.saveAsImage = function (name, type, quality, padding, thumbnail) {
    if (thumbnail === void 0) {
      thumbnail = true;
    }
    var a = document.createElement('a');
    a.setAttribute('download', name || 'le5le.topology.png');
    a.setAttribute('href', this.toImage(type, quality, null, padding, thumbnail));
    var evt = document.createEvent('MouseEvents');
    evt.initEvent('click', true, true);
    a.dispatchEvent(evt);
  };
  Topology.prototype.delete = function () {
    var pens = [];
    var i = 0;
    for (var _i = 0, _a = this.activeLayer.pens; _i < _a.length; _i++) {
      var line = _a[_i];
      i = this.find(line);
      if (i > -1) {
        if (this.data.pens[i].type === pen_1.PenType.Node) {
          this.divLayer.removeDiv(this.data.pens[i]);
        }
        pens.push.apply(pens, this.data.pens.splice(i, 1));
      }
    }
    this.animate(false);
    this.render(true);
    this.cache();
    this.dispatch('delete', pens);
  };
  Topology.prototype.removeNode = function (node) {
    var i = this.find(node);
    if (i > -1) {
      this.divLayer.removeDiv(this.data.pens[i]);
      var nodes = this.data.pens.splice(i, 1);
      this.dispatch('delete', {
        nodes: nodes
      });
    }
    this.render(true);
    this.cache();
  };
  Topology.prototype.removeLine = function (line) {
    var i = this.find(line);
    if (i > -1) {
      var lines = this.data.pens.splice(i, 1);
      this.dispatch('delete', {
        lines: lines
      });
    }
    this.render(true);
    this.cache();
  };
  Topology.prototype.cut = function () {
    if (this.data.locked) {
      return;
    }
    this.clipboard = new data_1.TopologyData({
      pens: []
    });
    for (var _i = 0, _a = this.activeLayer.pens; _i < _a.length; _i++) {
      var pen = _a[_i];
      this.clipboard.pens.push(pen.clone());
      var i = this.find(pen);
      if (i > -1) {
        if (pen.type === pen_1.PenType.Node) {
          this.divLayer.removeDiv(this.data.pens[i]);
        }
        this.data.pens.splice(i, 1);
      }
    }
    this.cache();
    this.activeLayer.clear();
    this.hoverLayer.node = null;
    this.moveIn.hoverLine = null;
    this.moveIn.hoverNode = null;
    this.render();
    this.dispatch('delete', {
      pens: this.clipboard.pens
    });
  };
  Topology.prototype.copy = function () {
    this.clipboard = new data_1.TopologyData({
      pens: []
    });
    for (var _i = 0, _a = this.activeLayer.pens; _i < _a.length; _i++) {
      var pen = _a[_i];
      this.clipboard.pens.push(pen.clone());
    }
  };
  Topology.prototype.paste = function () {
    if (!this.clipboard || this.data.locked) {
      return;
    }
    this.hoverLayer.node = null;
    this.hoverLayer.line = null;
    this.activeLayer.pens = [];
    var idMaps = {};
    for (var _i = 0, _a = this.clipboard.pens; _i < _a.length; _i++) {
      var pen = _a[_i];
      if (pen.type === pen_1.PenType.Node) {
        this.newId(pen, idMaps);
        pen.rect.x += 20;
        pen.rect.ex += 20;
        pen.rect.y += 20;
        pen.rect.ey += 20;
        pen.init();
      }
      if (pen instanceof line_1.Line) {
        pen.id = uuid_1.s8();
        pen.from = new point_1.Point(pen.from.x + 20, pen.from.y + 20, pen.from.direction, pen.from.anchorIndex, idMaps[pen.from.id]);
        pen.to = new point_1.Point(pen.to.x + 20, pen.to.y + 20, pen.to.direction, pen.to.anchorIndex, idMaps[pen.to.id]);
        var controlPoints = [];
        for (var _b = 0, _c = pen.controlPoints; _b < _c.length; _b++) {
          var pt = _c[_b];
          controlPoints.push(new point_1.Point(pt.x + 20, pt.y + 20));
        }
        pen.controlPoints = controlPoints;
      }
      this.data.pens.push(pen);
      this.activeLayer.add(pen);
    }
    this.render();
    this.cache();
    this.copy();
    if (this.clipboard.pens.length > 1) {
      this.dispatch('multi', {
        pens: this.clipboard.pens
      });
    } else if (this.activeLayer.pens[0].type === pen_1.PenType.Node) {
      this.dispatch('addNode', this.activeLayer.pens[0]);
    } else if (this.activeLayer.pens[0].type === pen_1.PenType.Line) {
      this.dispatch('addLine', this.activeLayer.pens[0]);
    }
  };
  Topology.prototype.newId = function (node, idMaps) {
    var old = node.id;
    node.id = uuid_1.s8();
    idMaps[old] = node.id;
    if (node.children) {
      for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
        var item = _a[_i];
        this.newId(item, idMaps);
      }
    }
  };
  Topology.prototype.animate = function (autoplay) {
    if (autoplay === void 0) {
      autoplay = false;
    }
    this.animateLayer.readyPlay(null, autoplay);
    this.animateLayer.animate();
  };
  Topology.prototype.updateProps = function (cache, pens) {
    if (cache === void 0) {
      cache = true;
    }
    if (!pens) {
      pens = this.activeLayer.pens;
    }
    for (var _i = 0, pens_1 = pens; _i < pens_1.length; _i++) {
      var pen = pens_1[_i];
      if (pen instanceof node_1.Node) {
        pen.init();
        pen.initRect();
      }
    }
    this.activeLayer.updateLines(pens); //节点变化后，重新计算默认连线
    this.activeLayer.calcControlPoints(); //计算4个顶点的大小控制点
    this.activeLayer.saveNodeRects(); //缩放前，备份初始位置
    this.activeLayer.changeLineType(); //连线类型改变，重新计算连线属性
    this.render();
    // tslint:disable-next-line: no-unused-expression
    cache && this.cache();
  };
  Topology.prototype.lock = function (lock) {
    this.data.locked = lock;
    this.dispatch('locked', this.data.locked);
  };
  Topology.prototype.lockPens = function (pens, lock) {
    for (var _i = 0, _a = this.data.pens; _i < _a.length; _i++) {
      var item = _a[_i];
      for (var _b = 0, pens_2 = pens; _b < pens_2.length; _b++) {
        var node = pens_2[_b];
        if (item.id === node.id) {
          item.locked = lock;
          break;
        }
      }
    }
    this.dispatch('lockPens', {
      pens: pens,
      lock: lock
    });
  };
  Topology.prototype.top = function (pen) {
    var i = this.find(pen);
    if (i > -1) {
      this.data.pens.push(this.data.pens[i]);
      this.data.pens.splice(i, 1);
    }
  };
  Topology.prototype.bottom = function (pen) {
    var i = this.find(pen);
    if (i > -1) {
      this.data.pens.unshift(this.data.pens[i]);
      this.data.pens.splice(i + 1, 1);
    }
  };
  Topology.prototype.combine = function (pens, lockChildren) {
    if (lockChildren === void 0) {
      lockChildren = false;
    }
    if (!pens) {
      pens = this.activeLayer.pens;
    }
    var rect = this.getRect(pens);
    for (var _i = 0, pens_3 = pens; _i < pens_3.length; _i++) {
      var item = pens_3[_i];
      var i = this.find(item);
      if (i > -1) {
        this.data.pens.splice(i, 1);
      }
    }
    var node = new node_1.Node({
      name: 'combine',
      rect: new rect_1.Rect(rect.x, rect.y, rect.width, rect.height),
      text: '',
      paddingLeft: 0,
      paddingRight: 0,
      paddingTop: 0,
      paddingBottom: 0,
      strokeStyle: 'transparent',
      children: []
    });
    for (var i = 0; i < pens.length; ++i) {
      if (pens[i].type === pen_1.PenType.Node && rect.width === pens[i].rect.width && rect.height === pens[i].rect.height) {
        node = pens[i];
        if (!node.children) {
          node.children = [];
        }
        pens.splice(i, 1);
        break;
      }
    }
    for (var _a = 0, pens_4 = pens; _a < pens_4.length; _a++) {
      var item = pens_4[_a];
      item.locked = lockChildren;
      item.parentId = node.id;
      item.calcRectInParent(node);
      node.children.push(item);
    }
    this.data.pens.push(node);
    this.activeLayer.setPens([node]);
    this.dispatch('node', node);
    this.cache();
  };
  Topology.prototype.uncombine = function (node) {
    if (!node) {
      node = this.activeLayer.pens[0];
    }
    if (!(node instanceof node_1.Node)) {
      return;
    }
    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
      var item = _a[_i];
      item.parentId = undefined;
      item.rectInParent = undefined;
      item.locked = false;
      this.data.pens.push(item);
    }
    var i = this.find(node);
    if (i > -1 && node.name === 'combine') {
      this.data.pens.splice(i, 1);
    } else {
      node.children = null;
    }
    this.cache();
    this.activeLayer.clear();
    this.hoverLayer.clear();
  };
  Topology.prototype.find = function (pen) {
    for (var i = 0; i < this.data.pens.length; ++i) {
      if (pen.id === this.data.pens[i].id) {
        return i;
      }
    }
    return -1;
  };
  Topology.prototype.translate = function (x, y, process) {
    if (!process) {
      this.lastTranlated.x = 0;
      this.lastTranlated.y = 0;
    }
    var offsetX = x - this.lastTranlated.x;
    var offsetY = y - this.lastTranlated.y;
    for (var _i = 0, _a = this.data.pens; _i < _a.length; _i++) {
      var item = _a[_i];
      item.translate(offsetX, offsetY);
    }
    this.lastTranlated.x = x;
    this.lastTranlated.y = y;
    this.overflow();
    this.render();
    this.cache();
    this.dispatch('translate', {
      x: x,
      y: y
    });
  };
  // scale for scaled canvas:
  //   > 1, expand
  //   < 1, reduce
  Topology.prototype.scale = function (scale) {
    if (this.data.scale * scale < this.options.minScale || this.data.scale * scale > this.options.maxScale) {
      return;
    }
    this.data.scale *= scale;
    var center = this.getRect().center;
    for (var _i = 0, _a = this.data.pens; _i < _a.length; _i++) {
      var item = _a[_i];
      item.scale(scale, center);
    }
    le5le_store_1.Store.set('LT:scale', this.data.scale);
    this.overflow();
    this.render();
    this.cache();
    this.dispatch('scale', this.data.scale);
  };
  // scale for origin canvas:
  Topology.prototype.scaleTo = function (scale) {
    this.scale(scale / this.data.scale);
  };
  Topology.prototype.round = function () {
    for (var _i = 0, _a = this.data.pens; _i < _a.length; _i++) {
      var item = _a[_i];
      if (item instanceof node_1.Node) {
        item.round();
      }
    }
  };
  Topology.prototype.createMarkdownTip = function () {
    this.tipMarkdown = document.createElement('div');
    this.tipMarkdown.style.position = 'fixed';
    this.tipMarkdown.style.zIndex = '-1';
    this.tipMarkdown.style.left = '-9999px';
    this.tipMarkdown.style.width = '500px';
    this.tipMarkdown.style.outline = 'none';
    this.tipMarkdown.style.border = '1px solid #d0d0d0';
    this.tipMarkdown.style.backgroundColor = '#fff';
    this.tipMarkdown.style.padding = '10px 15px';
    this.tipMarkdown.style.overflowY = 'auto';
    this.tipMarkdown.style.minHeight = '30px';
    this.tipMarkdown.style.maxHeight = '260px';
    document.body.appendChild(this.tipMarkdown);
  };
  Topology.prototype.showTip = function (data, pos) {
    if (!this.data.locked || !data || (!data.markdown && !data.tipId && !data.title) || data.id === this.tip) {
      return;
    }
    if (data.title) {
      this.divLayer.canvas.title = data.title;
      this.tip = data.id;
      return;
    }
    if (data.tipId) {
      this.tipElem = document.getElementById(data.tipId);
    }
    var elem = this.tipElem;
    if (data.markdown) {
      elem = this.tipMarkdown;
      var marked = window.marked;
      if (marked) {
        this.tipMarkdown.innerHTML = marked(data.markdown);
      } else {
        this.tipMarkdown.innerHTML = data.markdown;
      }
      var a = this.tipMarkdown.getElementsByTagName('A');
      for (var i = 0; i < a.length; ++i) {
        a[i].setAttribute('target', '_blank');
      }
    }
    var parentRect = this.parentElem.getBoundingClientRect();
    var elemRect = elem.getBoundingClientRect();
    var x = pos.x + parentRect.left - elemRect.width / 2;
    var y = pos.y + parentRect.top;
    if (data instanceof node_1.Node) {
      x = parentRect.left + data.rect.center.x - elemRect.width / 2;
      y = parentRect.top + data.rect.ey;
    }
    x -= this.parentElem.scrollLeft;
    y -= this.parentElem.scrollTop;
    if (x < 0) {
      x = 0;
    }
    if (x + elemRect.width > document.body.clientWidth) {
      x = document.body.clientWidth - elemRect.width;
    }
    if (y + elemRect.height > document.body.clientHeight) {
      y = document.body.clientHeight - elemRect.height;
    }
    elem.style.position = 'fixed';
    elem.style.left = x + 'px';
    elem.style.top = y + 'px';
    elem.style.zIndex = '100';
    this.tip = data.id;
    this.dispatch('tip', elem);
  };
  Topology.prototype.hideTip = function () {
    if (!this.tip) {
      return;
    }
    this.tipMarkdown.style.left = '-9999px';
    this.tipMarkdown.style.zIndex = '-1';
    if (this.tipElem) {
      this.tipElem.style.left = '-9999px';
      this.tipElem.style.zIndex = '-1';
      this.tipElem = null;
    }
    this.divLayer.canvas.title = '';
    this.tip = '';
  };
  Topology.prototype.scroll = function (x, y) {
    var _this = this;
    if (this.scrolling) {
      return;
    }
    this.scrolling = true;
    this.parentElem.scrollLeft += x;
    this.parentElem.scrollTop += y;
    setTimeout(function () {
      _this.scrolling = false;
    }, 700);
  };
  Topology.prototype.toComponent = function (pens) {
    if (!pens) {
      pens = this.data.pens;
    }
    var rect = this.getRect(pens);
    var node = new node_1.Node({
      name: 'combine',
      rect: new rect_1.Rect(rect.x, rect.y, rect.width, rect.height),
      text: '',
      paddingLeft: 0,
      paddingRight: 0,
      paddingTop: 0,
      paddingBottom: 0,
      strokeStyle: 'transparent',
      children: []
    });
    for (var _i = 0, pens_5 = pens; _i < pens_5.length; _i++) {
      var item = pens_5[_i];
      if (item.type === pen_1.PenType.Node && rect.width === item.rect.width && rect.height === item.rect.height) {
        node = item;
        if (!node.children) {
          node.children = [];
        }
        break;
      }
    }
    for (var _a = 0, pens_6 = pens; _a < pens_6.length; _a++) {
      var item = pens_6[_a];
      if (item !== node) {
        item.parentId = node.id;
        item.calcRectInParent(node);
        node.children.push(item);
      }
    }
    return node;
  };
  Topology.prototype.clearBkImg = function () {
    this.canvas.clearBkImg();
  };
  Topology.prototype.dispatch = function (event, data) {
    if (this.options.on) {
      this.options.on(event, data);
    }
  };
  Topology.prototype.destroy = function () {
    this.subcribe.unsubscribe();
    this.subcribeImage.unsubscribe();
    this.subcribeAnimateEnd.unsubscribe();
    this.subcribeAnimateMoved.unsubscribe();
    this.subcribeMediaEnd.unsubscribe();
    this.animateLayer.destroy();
    this.divLayer.destroy();
    document.body.removeChild(this.tipMarkdown);
  };
  return Topology;
}());
exports.Topology = Topology;
//# sourceMappingURL=index.js.map
